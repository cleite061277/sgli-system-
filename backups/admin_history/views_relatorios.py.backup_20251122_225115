"""
Views para Dashboard Financeiro - HABITAT PRO
Desenvolvido para visualiza√ß√£o de m√©tricas e sa√∫de financeira do neg√≥cio
"""
from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from django.http import HttpResponse, JsonResponse
from django.db.models import Sum, Count, Q, F, DecimalField
from django.db.models.functions import Coalesce
from django.views.decorators.http import require_http_methods
from datetime import date, timedelta
from decimal import Decimal
import json

from core.models import Comanda, Locacao, Imovel, Pagamento


@login_required
def dashboard_financeiro(request):
    """
    View principal do dashboard financeiro
    Exibe KPIs, gr√°ficos e an√°lises financeiras
    """
    # Filtros do usu√°rio
    periodo = request.GET.get('periodo', 'ano')
    imovel_id = request.GET.get('imovel', 'todos')
    status_filtro = request.GET.get('status', 'todos')
    visualizacao = request.GET.get('visualizacao', 'real')
    
    # Calcular range de datas baseado no per√≠odo
    hoje = date.today()
    ano_atual = hoje.year
    
    if periodo == 'mes':
        data_inicio = hoje.replace(day=1)
        data_fim = hoje
    elif periodo == 'trimestre':
        data_inicio = hoje - timedelta(days=90)
        data_fim = hoje
    elif periodo == 'semestre':
        data_inicio = hoje - timedelta(days=180)
        data_fim = hoje
    elif periodo == 'comparativo':
        # Ano atual vs ano anterior
        data_inicio = date(ano_atual - 1, 1, 1)
        data_fim = hoje
    else:  # 'ano' - padr√£o
        data_inicio = date(ano_atual, 1, 1)
        data_fim = date(ano_atual, 12, 31)
    
    # Montar queryset base de comandas
    queryset = Comanda.objects.filter(
        data_vencimento__gte=data_inicio,
        data_vencimento__lte=data_fim,
        is_active=True
    )
    
    # Aplicar filtros adicionais
    if imovel_id != 'todos':
        queryset = queryset.filter(locacao__imovel_id=imovel_id)
    
    if status_filtro == 'pago':
        queryset = queryset.filter(status__in=['PAID', 'PAGA'])
    elif status_filtro == 'pendente':
        queryset = queryset.filter(status='PENDING')
    elif status_filtro == 'atrasado':
        queryset = queryset.filter(status='OVERDUE')
    
    # Calcular KPIs principais
    kpis = calcular_kpis(queryset, hoje)
    
    # Dados mensais para gr√°ficos
    if periodo == 'comparativo':
        dados_mensais = calcular_comparativo_anual(ano_atual)
    else:
        dados_mensais = calcular_dados_mensais(ano_atual)
    
    # Performance por im√≥vel (top 5 + outros)
    performance_imoveis = calcular_performance_imoveis(ano_atual)
    
    # Gerar alertas baseados nos KPIs
    alertas = gerar_alertas(kpis, dados_mensais)
    
    # Proje√ß√£o (se solicitado)
    projecao = None
    if visualizacao == 'projecao':
        projecao = calcular_projecao(dados_mensais)
    
    # Lista de im√≥veis para filtro
    imoveis = Imovel.objects.filter(is_active=True).order_by('endereco')
    
    context = {
        'kpis': kpis,
        'dados_mensais_json': json.dumps(dados_mensais),
        'performance_imoveis_json': json.dumps(performance_imoveis),
        'alertas': alertas,
        'projecao_json': json.dumps(projecao) if projecao else None,
        'imoveis': imoveis,
        'ano_atual': ano_atual,
        'filtros': {
            'periodo': periodo,
            'imovel': imovel_id,
            'status': status_filtro,
            'visualizacao': visualizacao,
        }
    }
    
    return render(request, 'relatorios/dashboard_financeiro.html', context)


def calcular_kpis(queryset, data_referencia):
    """
    Calcula os 4 KPIs principais do dashboard
    
    Returns:
        dict com receita_prevista, receita_realizada, inadimplencia_*, taxa_ocupacao
    """
    # 1. RECEITA PREVISTA (soma de todas as comandas do per√≠odo)
    receita_prevista = queryset.aggregate(
        total=Coalesce(Sum('valor_total'), Decimal('0'))
    )['total']
    
    # 2. RECEITA REALIZADA (comandas pagas)
    receita_realizada = queryset.filter(
        status__in=['PAID', 'PAGA']
    ).aggregate(
        total=Coalesce(Sum('valor_total'), Decimal('0'))
    )['total']
    
    # 3. INADIMPL√äNCIA (comandas vencidas n√£o pagas)
    comandas_atrasadas = queryset.filter(
        data_vencimento__lt=data_referencia,
        status__in=['PENDING', 'OVERDUE']
    )
    
    inadimplencia_valor = comandas_atrasadas.aggregate(
        total=Coalesce(Sum('valor_total'), Decimal('0'))
    )['total']
    
    inadimplencia_qtd = comandas_atrasadas.count()
    
    # Percentual de inadimpl√™ncia
    inadimplencia_percentual = (
        float(inadimplencia_valor / receita_prevista * 100) 
        if receita_prevista > 0 else 0
    )
    
    # 4. TAXA DE OCUPA√á√ÉO (im√≥veis com loca√ß√£o ativa)
    total_imoveis = Imovel.objects.filter(is_active=True).count()
    
    imoveis_ocupados = Locacao.objects.filter(
        status='ATIVA',
        is_active=True
    ).values('imovel').distinct().count()
    
    taxa_ocupacao = (
        (imoveis_ocupados / total_imoveis * 100)
        if total_imoveis > 0 else 0
    )
    
    # Taxa de realiza√ß√£o (quanto % foi realizado do previsto)
    taxa_realizacao = (
        float(receita_realizada / receita_prevista * 100)
        if receita_prevista > 0 else 0
    )
    
    # Varia√ß√£o vs m√™s anterior (exemplo simplificado)
    variacao_percentual = 12.0  # TODO: calcular real baseado em m√™s anterior
    
    return {
        'receita_prevista': float(receita_prevista),
        'receita_realizada': float(receita_realizada),
        'inadimplencia_valor': float(inadimplencia_valor),
        'inadimplencia_qtd': inadimplencia_qtd,
        'inadimplencia_percentual': round(inadimplencia_percentual, 1),
        'taxa_ocupacao': round(taxa_ocupacao, 1),
        'taxa_realizacao': round(taxa_realizacao, 1),
        'total_imoveis': total_imoveis,
        'imoveis_ocupados': imoveis_ocupados,
        'variacao_percentual': variacao_percentual,
    }


def calcular_dados_mensais(ano):
    """
    Calcula dados agregados por m√™s para gr√°ficos
    
    Returns:
        list de dicts com dados de cada m√™s
    """
    meses_data = []
    mes_atual = date.today().month
    
    for mes in range(1, 13):
        # S√≥ calcular at√© o m√™s atual
        if mes > mes_atual and ano == date.today().year:
            break
            
        # Filtrar comandas do m√™s
        comandas_mes = Comanda.objects.filter(
            mes_referencia=mes,
            ano_referencia=ano,
            is_active=True
        )
        
        # Receita prevista
        previsto = comandas_mes.aggregate(
            total=Coalesce(Sum('valor_total'), Decimal('0'))
        )['total']
        
        # Receita realizada (pagas)
        realizado = comandas_mes.filter(
            status__in=['PAID', 'PAGA']
        ).aggregate(
            total=Coalesce(Sum('valor_total'), Decimal('0'))
        )['total']
        
        # Inadimpl√™ncia (atrasadas)
        atrasadas = comandas_mes.filter(
            data_vencimento__lt=date.today(),
            status__in=['PENDING', 'OVERDUE']
        )
        
        inadimplencia_valor = atrasadas.aggregate(
            total=Coalesce(Sum('valor_total'), Decimal('0'))
        )['total']
        
        # Percentual de inadimpl√™ncia
        inadimplencia_percentual = (
            float(inadimplencia_valor / previsto * 100)
            if previsto > 0 else 0
        )
        
        # Taxa de realiza√ß√£o
        taxa_realizacao = (
            float(realizado / previsto * 100)
            if previsto > 0 else 0
        )
        
        # Nome do m√™s
        nome_mes = date(ano, mes, 1).strftime('%b')
        
        meses_data.append({
            'mes': mes,
            'nome_mes': nome_mes,
            'previsto': float(previsto),
            'realizado': float(realizado),
            'inadimplencia': round(inadimplencia_percentual, 1),
            'taxa_realizacao': round(taxa_realizacao, 1),
            'diferenca': float(realizado - previsto),
        })
    
    return meses_data


def calcular_comparativo_anual(ano_atual):
    """
    Calcula comparativo entre ano atual e ano anterior
    """
    # TODO: Implementar comparativo 2024 vs 2025
    # Por enquanto, retorna apenas ano atual
    return calcular_dados_mensais(ano_atual)


def calcular_performance_imoveis(ano):
    """
    Calcula performance dos top 5 im√≥veis + categoria 'Outros'
    
    Returns:
        list de dicts com performance de cada im√≥vel
    """
    imoveis_performance = []
    
    # Calcular para cada im√≥vel
    imoveis = Imovel.objects.filter(is_active=True).annotate(
        total_previsto=Coalesce(
            Sum('locacao__comanda__valor_total',
                filter=Q(locacao__comanda__ano_referencia=ano,
                        locacao__comanda__is_active=True)),
            Decimal('0')
        ),
        total_realizado=Coalesce(
            Sum('locacao__comanda__valor_total',
                filter=Q(locacao__comanda__ano_referencia=ano,
                        locacao__comanda__status__in=['PAID', 'PAGA'],
                        locacao__comanda__is_active=True)),
            Decimal('0')
        )
    ).order_by('-total_previsto')
    
    # Top 5 im√≥veis
    top_5 = imoveis[:5]
    
    for imovel in top_5:
        previsto = float(imovel.total_previsto)
        realizado = float(imovel.total_realizado)
        taxa = (realizado / previsto * 100) if previsto > 0 else 0
        
        imoveis_performance.append({
            'nome': f"{imovel.tipo_imovel} - {imovel.endereco}, {imovel.numero}",
            'previsto': previsto,
            'realizado': realizado,
            'taxa': round(taxa, 1)
        })
    
    # Agregar "Outros" (im√≥veis 6+)
    outros = imoveis[5:]
    if outros:
        outros_previsto = sum(float(i.total_previsto) for i in outros)
        outros_realizado = sum(float(i.total_realizado) for i in outros)
        outros_taxa = (outros_realizado / outros_previsto * 100) if outros_previsto > 0 else 0
        
        imoveis_performance.append({
            'nome': f'Outros ({len(outros)} im√≥veis)',
            'previsto': outros_previsto,
            'realizado': outros_realizado,
            'taxa': round(outros_taxa, 1)
        })
    
    return imoveis_performance


def calcular_projecao(dados_mensais):
    """
    Calcula proje√ß√£o linear para pr√≥ximos 3 meses
    Usa os √∫ltimos 6 meses como base
    """
    if len(dados_mensais) < 6:
        return None
    
    # Pegar √∫ltimos 6 meses
    ultimos_6 = dados_mensais[-6:]
    valores = [m['realizado'] for m in ultimos_6]
    
    # Calcular tend√™ncia (m√©dia simples de crescimento)
    if len(valores) >= 2:
        crescimento_medio = (valores[-1] - valores[0]) / len(valores)
    else:
        crescimento_medio = 0
    
    # Projetar pr√≥ximos 3 meses
    projecao = []
    ultimo_valor = valores[-1]
    
    for i in range(1, 4):
        valor_projetado = ultimo_valor + (crescimento_medio * i)
        projecao.append({
            'mes': f'Proje√ß√£o +{i}',
            'previsto': round(valor_projetado * 1.02, 2),  # Previsto ligeiramente maior
            'estimado': round(max(0, valor_projetado), 2)
        })
    
    return projecao


def gerar_alertas(kpis, dados_mensais):
    """
    Gera alertas baseados em KPIs e tend√™ncias
    
    Returns:
        list de dicts com alertas
    """
    alertas = []
    
    # Alerta 1: Inadimpl√™ncia acima da meta (3%)
    if kpis['inadimplencia_percentual'] > 3:
        alertas.append({
            'tipo': 'warning',
            'titulo': '‚ö†Ô∏è Inadimpl√™ncia acima da meta',
            'mensagem': f"Inadimpl√™ncia atual: {kpis['inadimplencia_percentual']}% (Meta: 3%). "
                       f"Total de {kpis['inadimplencia_qtd']} comandas atrasadas.",
            'acao': 'Ver comandas atrasadas',
            'link': '/admin/core/comanda/?status=OVERDUE'
        })
    
    # Alerta 2: Taxa de realiza√ß√£o baixa (<90%)
    if kpis['taxa_realizacao'] < 90:
        alertas.append({
            'tipo': 'warning',
            'titulo': 'üìâ Taxa de realiza√ß√£o abaixo do esperado',
            'mensagem': f"Apenas {kpis['taxa_realizacao']}% da receita prevista foi realizada.",
            'acao': 'Ver pend√™ncias',
            'link': '/admin/core/comanda/?status=PENDING'
        })
    
    # Alerta 3: Proje√ß√£o dispon√≠vel (informativo)
    if len(dados_mensais) >= 6:
        ultimo_mes = dados_mensais[-1]
        alertas.append({
            'tipo': 'info',
            'titulo': 'üìä Proje√ß√£o dispon√≠vel',
            'mensagem': f"Baseado na tend√™ncia dos √∫ltimos 6 meses, a proje√ß√£o para o pr√≥ximo m√™s √© de R$ {ultimo_mes['realizado']:,.2f}",
            'acao': 'Ver proje√ß√£o completa',
            'link': '?visualizacao=projecao'
        })
    
    # Alerta 4: Taxa de ocupa√ß√£o baixa (<85%)
    if kpis['taxa_ocupacao'] < 85:
        alertas.append({
            'tipo': 'warning',
            'titulo': 'üè† Taxa de ocupa√ß√£o baixa',
            'mensagem': f"Apenas {kpis['imoveis_ocupados']} de {kpis['total_imoveis']} im√≥veis est√£o ocupados ({kpis['taxa_ocupacao']}%).",
            'acao': 'Ver im√≥veis dispon√≠veis',
            'link': '/admin/core/imovel/?locacao__isnull=True'
        })
    
    return alertas


@login_required
@require_http_methods(["GET"])
def exportar_dashboard_excel(request):
    """
    Exporta dashboard completo para Excel
    """
    from core.reports.export_service import ExportService
    
    # Calcular dados
    ano_atual = date.today().year
    queryset = Comanda.objects.filter(
        ano_referencia=ano_atual,
        is_active=True
    )
    
    kpis = calcular_kpis(queryset, date.today())
    dados_mensais = calcular_dados_mensais(ano_atual)
    performance_imoveis = calcular_performance_imoveis(ano_atual)
    
    # Gerar Excel
    response = ExportService.gerar_excel_dashboard(
        kpis, dados_mensais, performance_imoveis
    )
    
    return response


@login_required
@require_http_methods(["GET"])
def exportar_dashboard_pdf(request):
    """
    Exporta dashboard completo para PDF
    """
    from core.reports.export_service import ExportService
    
    # Calcular dados
    ano_atual = date.today().year
    queryset = Comanda.objects.filter(
        ano_referencia=ano_atual,
        is_active=True
    )
    
    kpis = calcular_kpis(queryset, date.today())
    dados_mensais = calcular_dados_mensais(ano_atual)
    performance_imoveis = calcular_performance_imoveis(ano_atual)
    
    # Gerar PDF
    response = ExportService.gerar_pdf_dashboard(
        kpis, dados_mensais, performance_imoveis
    )
    
    return response


@login_required
@require_http_methods(["POST"])
def enviar_relatorio_email(request):
    """
    Envia relat√≥rio completo por email (PDF + Excel anexados)
    """
    from core.reports.export_service import ExportService
    from django.core.mail import EmailMessage
    import io
    
    # Validar email
    destinatario = request.POST.get('email', '').strip()
    if not destinatario:
        return JsonResponse({
            'status': 'error',
            'mensagem': 'Email n√£o informado'
        }, status=400)
    
    # Calcular dados
    ano_atual = date.today().year
    queryset = Comanda.objects.filter(
        ano_referencia=ano_atual,
        is_active=True
    )
    
    kpis = calcular_kpis(queryset, date.today())
    dados_mensais = calcular_dados_mensais(ano_atual)
    performance_imoveis = calcular_performance_imoveis(ano_atual)
    
    try:
        # Gerar arquivos
        pdf_response = ExportService.gerar_pdf_dashboard(
            kpis, dados_mensais, performance_imoveis
        )
        excel_response = ExportService.gerar_excel_dashboard(
            kpis, dados_mensais, performance_imoveis
        )
        
        # Criar email
        email = EmailMessage(
            subject=f'HABITAT PRO - Relat√≥rio Financeiro {ano_atual}',
            body=f'''Ol√°,

Segue em anexo o relat√≥rio financeiro completo do HABITAT PRO referente ao ano de {ano_atual}.

Principais indicadores:
- Receita Prevista: R$ {kpis['receita_prevista']:,.2f}
- Receita Realizada: R$ {kpis['receita_realizada']:,.2f}
- Taxa de Realiza√ß√£o: {kpis['taxa_realizacao']}%
- Inadimpl√™ncia: {kpis['inadimplencia_percentual']}%
- Taxa de Ocupa√ß√£o: {kpis['taxa_ocupacao']}%

Atenciosamente,
Sistema HABITAT PRO
''',
            from_email='sistema@habitatpro.com.br',
            to=[destinatario]
        )
        
        # Anexar arquivos
        email.attach(
            f'relatorio_financeiro_{ano_atual}.pdf',
            pdf_response.content,
            'application/pdf'
        )
        email.attach(
            f'dados_financeiros_{ano_atual}.xlsx',
            excel_response.content,
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        )
        
        # Enviar
        email.send()
        
        return JsonResponse({
            'status': 'success',
            'mensagem': f'Email enviado com sucesso para {destinatario}!'
        })
        
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'mensagem': f'Erro ao enviar email: {str(e)}'
        }, status=500)
